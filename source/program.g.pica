; Example PICA200 geometry shader
.gsh point c0
;Types of geometry shaders: point, variable-sized primitive and fixed-size primitive

; Uniforms
.fvec projection[4]
.ivec unif_loop_i0
.ivec unif_loop_i1

; Global constants
.constf myconst(0.0, 1.0, -1.0, 0.5)
.alias  zeros myconst.xxxx ; Vector full of zeros
.alias  ones  myconst.yyyy ; Vector full of ones
.alias  half  myconst.wwww

.constf iResolution(400.0, 240.0, 0, 0)
.constf iResolutionInverse(0.0025, 0.004166666666666667, 0, 0)

.constf auxFragCoordConsts(-0.0025, -0.004166666666666667, 0, 0)

.constf initialTrianglePos(0.5, 1.0, 0.5, 1.0)
.constf offsetPixTriV1(-0.5, -1.0, 0, 0)
.constf offsetPixTriV2(0.5, -1.0, 0, 0)
.constf orange(1.0, 0.77, 0.02, 1.0)

; Shader constants
.constf shaderConst1(0, 1, 0.075, 1.0)

; Outputs - this time the type *is* used
.out outpos position
.out outclr color

; Inputs: we will receive the following inputs:
; v0-v1: position/color of the first vertex
; v2-v3: position/color of the second vertex
; v4-v5: position/color of the third vertex
; SUMMARY: vX where X is even (parell) -> position, if X is odd -> color

.entry gmain
.proc gmain
	mov r15, offsetPixTriV1
	mov r14, offsetPixTriV2
	mov r13, iResolutionInverse; iResolution

	mov r3, initialTrianglePos ;tmpPos
	mov r4, myconst.yxxx ;tmpDisplacementX (1,0,0,0)
	mov r5, myconst.xyxx ;tmpDisplacementY (0,1,0,0)
	for i0 ; 0->199
		mov r0, r3
		for i1 ; 0->239
			;calculate fragCoord
			mov r12, auxFragCoordConsts
			mul r12, r0, r12 ; for the moment we get x and y from r0 which will have a 0.5f offset
			;mov r1, myconst.wwxx
			;add r12, r1, r12

			call mainImage
			;set vertex positions
			add r1, r0, r15
			add r2, r0, r14
			;mul r9, r13, r0
			;mov r9.zw, myconst.yy
			call emit_triangle_solid_color
			add r0, r0, r5
		.end
		add r3, r3, r4
	.end

	for i0 ; 0->199
		mov r0, r3
		for i1 ; 0->239
			call mainImage
			;set vertex positions
			add r1, r0, r15
			add r2, r0, r14
			mul r9, r13, r0
			mov r9.zw, myconst.yy
			;mov r9, orange ; ignore for the moment
			call emit_triangle_solid_color
			add r0, r0, r5
		.end
		add r3, r3, r4
	.end

	; We're finished
	end
.end

; Can MODIFY registers r1-2, 6-8, 10-11
; Has to put the resulting color to r9 with w=1.0
; in vec2 fragCoord r12 (0.5 -> -0.5)
; out vec4 fragColor -> r9
.proc mainImage
	; vec2 uv = fragCoord.xy / iResolution.xy;
	mul r8, r12, r13
	;mov r8.x, myconst.y
	;fragColor = vec4(uv,0.5+0.5*0.3,1.0);

	;mov r9.zw, shaderConst1.zw
	mov r9, shaderConst1
	mov r9.xy, r8.xy ; aixo no fa el mateix que abans que vol dir que no entenc com funciona el mov/swizzle, revisar linia 54
.end

; Subroutine
; Inputs:
;   r0: vertex 1 position 
;   r1: vertex 2 position
;   r2: vertex 3 position
;	r9: solid color
.proc emit_triangle_solid_color
	; Emit the first vertex
	setemit 0
	mov r8, r0
	call process_vertex
	emit

	; Emit the second vertex
	setemit 1
	mov r8, r1
	call process_vertex
	emit

	; Emit the third vertex and finish the primitive
	setemit 2, prim
	mov r8, r2
	call process_vertex
	emit
.end

; Subroutine
; Inputs:
;   r8: vertex position
;   r9: vertex color
.proc process_vertex
	; outpos = projectionMatrix * r8
	dp4 outpos.x, projection[0], r8
	dp4 outpos.y, projection[1], r8
	dp4 outpos.z, projection[2], r8
	dp4 outpos.w, projection[3], r8

	; outclr = r9
	mov outclr, r9
.end
