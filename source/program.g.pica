; Example PICA200 geometry shader
.gsh point c0
;Types of geometry shaders: point, variable-sized primitive and fixed-size primitive

; Uniforms
.fvec projection[4]

; Constants
.constf myconst(0.0, 1.0, -1.0, 0.5)
.alias  zeros myconst.xxxx ; Vector full of zeros
.alias  ones  myconst.yyyy ; Vector full of ones
.alias  half  myconst.wwww

.constf orange(1.0, 0.77, 0.02, 1.0)

.constf triangle3V1(0.5, 5.0, 0.5, 1.0)
.constf offsetPixTriV1(-0.5, -1.0, 0, 0)
.constf offsetPixTriV2(0.5, -1.0, 0, 0)

.constf triangleUP(0.5, 6.0, 0.5, 1.0)
.constf triangleRIGHT(1.5, 5.0, 0.5, 1.0)
.constf triangleDOWN(0.5, 4.0, 0.5, 1.0)
.constf color1(0.47, 0.03, 0.3, 1.0)
.constf color2(0.29, 0.55, 0.29, 1.0)
.constf color3(0.57, 0.49, 0.45, 1.0)

; Outputs - this time the type *is* used
.out outpos position
.out outclr color

; Inputs: we will receive the following inputs:
; v0-v1: position/color of the first vertex
; v2-v3: position/color of the second vertex
; v4-v5: position/color of the third vertex
; SUMMARY: vX where X is even (parell) -> position, if X is odd -> color

.entry gmain
.proc gmain
	mov r15, offsetPixTriV1
	mov r14, offsetPixTriV2

	;set vertex positions
	mov r0, triangle3V1
	add r1, r0, r15
	add r2, r0, r14
	;set solid color
	mov r9, orange
	call emit_triangle_solid_color
	
	;UP
	mov r0, triangleUP
	add r1, r0, r15
	add r2, r0, r14
	;set solid color
	mov r9, color1
	call emit_triangle_solid_color

	;right
	mov r0, triangleRIGHT
	add r1, r0, r15
	add r2, r0, r14
	;set solid color
	mov r9, color2
	call emit_triangle_solid_color

	;down
	mov r0, triangleDOWN
	add r1, r0, r15
	add r2, r0, r14
	;set solid color
	mov r9, color3
	call emit_triangle_solid_color

	; We're finished
	end
.end

; Subroutine
; Inputs:
;   r0: vertex 1 position 
;   r1: vertex 2 position
;   r2: vertex 3 position
; Relies on:
;   v1: vertex 1 color 
;   v3: vertex 2 color
;   v5: vertex 3 color
.proc emit_triangle
	; Emit the first vertex
	setemit 0
	mov r8, r0
	mov r9, v1
	call process_vertex
	emit

	; Emit the second vertex
	setemit 1
	mov r8, r1
	mov r9, v3
	call process_vertex
	emit

	; Emit the third vertex and finish the primitive
	setemit 2, prim
	mov r8, r2
	mov r9, v5
	call process_vertex
	emit
.end

; Subroutine
; Inputs:
;   r0: vertex 1 position 
;   r1: vertex 2 position
;   r2: vertex 3 position
;	r9: solid color
.proc emit_triangle_solid_color
	; Emit the first vertex
	setemit 0
	mov r8, r0
	call process_vertex
	emit

	; Emit the second vertex
	setemit 1
	mov r8, r1
	call process_vertex
	emit

	; Emit the third vertex and finish the primitive
	setemit 2, prim
	mov r8, r2
	call process_vertex
	emit
.end

; Subroutine
; Inputs:
;   r8: vertex position
;   r9: vertex color
.proc process_vertex
	; outpos = projectionMatrix * r8
	dp4 outpos.x, projection[0], r8
	dp4 outpos.y, projection[1], r8
	dp4 outpos.z, projection[2], r8
	dp4 outpos.w, projection[3], r8

	; outclr = r9
	mov outclr, r9
.end
